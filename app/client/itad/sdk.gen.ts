// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { LookupGidTitleV1Data, LookupGidTitleV1Response, LookupGidTitleV1Error, LookupGidShopidV1Data, LookupGidShopidV1Response, LookupGidShopidV1Error, LookupShopidGidV1Data, LookupShopidGidV1Response, LookupShopidGidV1Error, GamesSearchV1Data, GamesSearchV1Response, GamesSearchV1Error, GamesLookupV1Data, GamesLookupV1Response, GamesLookupV1Error, GamesInfoV2Data, GamesInfoV2Response, GamesInfoV2Error, GamesPricesV3Data, GamesPricesV3Response, GamesPricesV3Error, GamesBundlesV2Data, GamesBundlesV2Response, GamesBundlesV2Error, GamesOverviewV2Data, GamesOverviewV2Response, GamesOverviewV2Error, GamesHistorylowV1Data, GamesHistorylowV1Response, GamesHistorylowV1Error, GamesStorelowV2Data, GamesStorelowV2Response, GamesStorelowV2Error, GamesHistoryV2Data, GamesHistoryV2Response, GamesHistoryV2Error, GamesSubscriptionsV1Data, GamesSubscriptionsV1Response, GamesSubscriptionsV1Error, DealsV2Data, DealsV2Response, DealsV2Error, WaitlistGamesV1DeleteData, WaitlistGamesV1DeleteResponse, WaitlistGamesV1DeleteError, WaitlistGamesV1GetData, WaitlistGamesV1GetResponse, WaitlistGamesV1GetError, WaitlistGamesV1PutData, WaitlistGamesV1PutResponse, WaitlistGamesV1PutError, CollectionGamesV1DeleteData, CollectionGamesV1DeleteResponse, CollectionGamesV1DeleteError, CollectionGamesV1GetData, CollectionGamesV1GetResponse, CollectionGamesV1GetError, CollectionGamesV1PutData, CollectionGamesV1PutResponse, CollectionGamesV1PutError, CollectionCopiesV1DeleteData, CollectionCopiesV1DeleteError, CollectionCopiesV1GetData, CollectionCopiesV1GetResponse, CollectionCopiesV1GetError, CollectionCopiesV1PatchData, CollectionCopiesV1PatchError, CollectionCopiesV1PostData, CollectionCopiesV1PostError, CollectionGroupsV1DeleteData, CollectionGroupsV1DeleteError, CollectionGroupsV1GetData, CollectionGroupsV1GetResponse, CollectionGroupsV1GetError, CollectionGroupsV1PatchData, CollectionGroupsV1PatchResponse, CollectionGroupsV1PatchError, CollectionGroupsV1PostData, CollectionGroupsV1PostResponse, CollectionGroupsV1PostError, StatsWaitlistV1Data, StatsWaitlistV1Response, StatsWaitlistV1Error, StatsMostWaitlistedV1Data, StatsMostWaitlistedV1Response, StatsMostWaitlistedV1Error, StatsMostCollectedV1Data, StatsMostCollectedV1Response, StatsMostCollectedV1Error, StatsMostPopularV1Data, StatsMostPopularV1Response, StatsMostPopularV1Error, UserInfoV2Data, UserInfoV2Response, UserInfoV2Error, UserNotesV1DeleteData, UserNotesV1DeleteError, UserNotesV1GetData, UserNotesV1GetResponse, UserNotesV1GetError, UserNotesV1PutData, UserNotesV1PutError, ProfilesLinkV1DeleteData, ProfilesLinkV1DeleteError, ProfilesLinkV1PutData, ProfilesLinkV1PutResponse, ProfilesLinkV1PutError, ProfilesSyncWaitlistV1PutData, ProfilesSyncWaitlistV1PutResponse, ProfilesSyncWaitlistV1PutError, ProfilesSyncCollectionV1PutData, ProfilesSyncCollectionV1PutResponse, ProfilesSyncCollectionV1PutError, NotificationsListV1GetData, NotificationsListV1GetResponse, NotificationsListV1GetError, NotificationsWaitlistV1GetData, NotificationsWaitlistV1GetResponse, NotificationsWaitlistV1GetError, NotificationsReadV1PutData, NotificationsReadV1PutResponse, NotificationsReadV1PutError, NotificationsReadAllV1PutData, NotificationsReadAllV1PutResponse, NotificationsReadAllV1PutError, ServiceShopsV1Data, ServiceShopsV1Response, ServiceShopsV1Error, InternalEarlyaccessV1Data, InternalEarlyaccessV1Response, InternalEarlyaccessV1Error, InternalPlayersV1Data, InternalPlayersV1Response, InternalPlayersV1Error, InternalHltbV1Data, InternalHltbV1Response, InternalHltbV1Error, InternalReviewsV1Data, InternalReviewsV1Response, InternalReviewsV1Error, InternalRatesV1Data, InternalRatesV1Response, InternalRatesV1Error, InternalExfglsV1Data, InternalExfglsV1Response, InternalExfglsV1Error, InternalTwitchstreamV1Data, InternalTwitchstreamV1Response, InternalTwitchstreamV1Error } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Lookup ITAD game IDs by title
 * Lookup IsThereAnyDeal's game IDs by title
 * This is not a full fledged search. Some title preprocessing will happen, but the lookup will only return IDs for titles, that match precisely.
 * Typos or variations in title may not give you expected result.
 */
export const lookupGidTitleV1 = <ThrowOnError extends boolean = false>(options?: Options<LookupGidTitleV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<LookupGidTitleV1Response, LookupGidTitleV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/lookup/id/title/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Lookup ITAD game IDs by IDs on shop
 * Lookup IsThereAnyDeal's game IDs by shop's game IDs
 */
export const lookupGidShopidV1 = <ThrowOnError extends boolean = false>(options: Options<LookupGidShopidV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LookupGidShopidV1Response, LookupGidShopidV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/lookup/id/shop/{shopId}/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Lookup game IDs on shop by ITAD game IDs
 * Lookup shop's game IDs by IsThereAnyDeal game IDs
 */
export const lookupShopidGidV1 = <ThrowOnError extends boolean = false>(options: Options<LookupShopidGidV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LookupShopidGidV1Response, LookupShopidGidV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/lookup/shop/{shopId}/id/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Search
 * Search for games by title
 */
export const gamesSearchV1 = <ThrowOnError extends boolean = false>(options: Options<GamesSearchV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesSearchV1Response, GamesSearchV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/search/v1',
        ...options
    });
};

/**
 * Lookup Game
 * Lookup game based on title or Steam appid
 */
export const gamesLookupV1 = <ThrowOnError extends boolean = false>(options?: Options<GamesLookupV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GamesLookupV1Response, GamesLookupV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/lookup/v1',
        ...options
    });
};

/**
 * Game Info
 * Get basic game information
 */
export const gamesInfoV2 = <ThrowOnError extends boolean = false>(options: Options<GamesInfoV2Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesInfoV2Response, GamesInfoV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/info/v2',
        ...options
    });
};

/**
 * Prices
 * Get games' prices
 */
export const gamesPricesV3 = <ThrowOnError extends boolean = false>(options?: Options<GamesPricesV3Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GamesPricesV3Response, GamesPricesV3Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/games/prices/v3',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Bundles including Game
 * Get all bundles which contain the game
 */
export const gamesBundlesV2 = <ThrowOnError extends boolean = false>(options: Options<GamesBundlesV2Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesBundlesV2Response, GamesBundlesV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/bundles/v2',
        ...options
    });
};

/**
 * Price Overview
 * Get basic price overview for selected games.
 *
 * For each game current best price will be loaded (optionally, only from selected shops),
 * historical low price (among all covered shops).
 *
 * Furthermore, result will also contain list of currently active bundles,
 * which contain at least one of the queried games.
 *
 */
export const gamesOverviewV2 = <ThrowOnError extends boolean = false>(options?: Options<GamesOverviewV2Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GamesOverviewV2Response, GamesOverviewV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/games/overview/v2',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * History Low
 * Get historically lowest prices
 */
export const gamesHistorylowV1 = <ThrowOnError extends boolean = false>(options?: Options<GamesHistorylowV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GamesHistorylowV1Response, GamesHistorylowV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/historylow/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Store Low
 * Get historically lowest prices for individual stores
 */
export const gamesStorelowV2 = <ThrowOnError extends boolean = false>(options?: Options<GamesStorelowV2Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GamesStorelowV2Response, GamesStorelowV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/games/storelow/v2',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * History log
 * Get log of historical prices
 */
export const gamesHistoryV2 = <ThrowOnError extends boolean = false>(options: Options<GamesHistoryV2Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GamesHistoryV2Response, GamesHistoryV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/games/history/v2',
        ...options
    });
};

/**
 * Game Subscriptions
 * Get list of subscriptions the game is listed in.
 *
 */
export const gamesSubscriptionsV1 = <ThrowOnError extends boolean = false>(options?: Options<GamesSubscriptionsV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GamesSubscriptionsV1Response, GamesSubscriptionsV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/games/subs/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Deals List
 * Get current deals. Follows same rules as deals list displayed on the website, which means that
 * you will not get one game more than once in the list.
 *
 * For each game, the best price is displayed, ignoring stores that currently don't have game on sale,
 * even if they currently have a better price.
 *
 */
export const dealsV2 = <ThrowOnError extends boolean = false>(options?: Options<DealsV2Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<DealsV2Response, DealsV2Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        querySerializer: {
            array: {
                explode: false,
                style: 'form'
            }
        },
        url: '/deals/v2',
        ...options
    });
};

/**
 * Delete from Waitlist
 * Delete games from user's Waitlist
 */
export const waitlistGamesV1Delete = <ThrowOnError extends boolean = false>(options?: Options<WaitlistGamesV1DeleteData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<WaitlistGamesV1DeleteResponse, WaitlistGamesV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/waitlist/games/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Games in Waitlist
 * Get games in user's Waitlist
 */
export const waitlistGamesV1Get = <ThrowOnError extends boolean = false>(options?: Options<WaitlistGamesV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<WaitlistGamesV1GetResponse, WaitlistGamesV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/waitlist/games/v1',
        ...options
    });
};

/**
 * Add to Waitlist
 * Add games to user's Waitlist
 */
export const waitlistGamesV1Put = <ThrowOnError extends boolean = false>(options?: Options<WaitlistGamesV1PutData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).put<WaitlistGamesV1PutResponse, WaitlistGamesV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/waitlist/games/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete from Collection
 * Delete games from user's Collection
 */
export const collectionGamesV1Delete = <ThrowOnError extends boolean = false>(options?: Options<CollectionGamesV1DeleteData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<CollectionGamesV1DeleteResponse, CollectionGamesV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/games/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Games in Collection
 * Get games in user's Collection
 */
export const collectionGamesV1Get = <ThrowOnError extends boolean = false>(options?: Options<CollectionGamesV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<CollectionGamesV1GetResponse, CollectionGamesV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/games/v1',
        ...options
    });
};

/**
 * Add to Collection
 * Add games to user's Collection
 */
export const collectionGamesV1Put = <ThrowOnError extends boolean = false>(options?: Options<CollectionGamesV1PutData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).put<CollectionGamesV1PutResponse, CollectionGamesV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/games/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete Copies
 * Delete Collection copies.
 *
 * Copies that do not exist or don't belong to user will be silently ignored.
 *
 * Operation is atomic. Either all copies are deleted or none.
 *
 */
export const collectionCopiesV1Delete = <ThrowOnError extends boolean = false>(options?: Options<CollectionCopiesV1DeleteData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<unknown, CollectionCopiesV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/copies/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List Copies
 * Get all copies user has in their Collection. Copies are returned as a simple list.
 *
 * It is not necessary to have copy for each game in Collection, so you should not rely on this endpoint
 * if you need to know about all games in user's Collection.
 *
 */
export const collectionCopiesV1Get = <ThrowOnError extends boolean = false>(options?: Options<CollectionCopiesV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<CollectionCopiesV1GetResponse, CollectionCopiesV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/copies/v1',
        ...options
    });
};

/**
 * Update Copies
 * Update one or more copies.
 *
 * You can issue partial updates on copy, only properties that are included for a copy will be updated.
 *
 * This operation is atomic, either all copies are updated or none.
 *
 */
export const collectionCopiesV1Patch = <ThrowOnError extends boolean = false>(options?: Options<CollectionCopiesV1PatchData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).patch<unknown, CollectionCopiesV1PatchError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/copies/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Add Copies
 * Add new copies. If the game is not already in a Collection, it will be added. Similarly, new tags will also be created.
 *
 * Same copies may exist multiple times for a single game, ITAD does not check for duplicates.
 *
 * This operation is atomic, either all copies are added or none.
 *
 */
export const collectionCopiesV1Post = <ThrowOnError extends boolean = false>(options?: Options<CollectionCopiesV1PostData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<unknown, CollectionCopiesV1PostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/copies/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete Categories
 * Delete Collection categories.
 *
 * Default category or categories that do not exist or user does not own will be silently ignored.
 *
 */
export const collectionGroupsV1Delete = <ThrowOnError extends boolean = false>(options?: Options<CollectionGroupsV1DeleteData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<unknown, CollectionGroupsV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/groups/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get all Categories
 * Get all Collection categories, both the user created ones and default one.
 * Default category has id 0 and will always be listed last. User set order of categories is respected in the response.
 *
 */
export const collectionGroupsV1Get = <ThrowOnError extends boolean = false>(options?: Options<CollectionGroupsV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<CollectionGroupsV1GetResponse, CollectionGroupsV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/groups/v1',
        ...options
    });
};

/**
 * Update Categories
 * Update one or more categories.
 *
 * For each category that you are going to update, only `id` is required. Fields that you do not want to update may be
 * set to `null` or omitted fully. Categories that do not exist or user does not own will be ignored.
 *
 * Default category (id: `0`) may have only `public` property updated. Other properties will be ignored.
 *
 * This operation is atomic, either all categories update or none. Successful response is the full category list,
 * including categories that were not updated.
 *
 */
export const collectionGroupsV1Patch = <ThrowOnError extends boolean = false>(options?: Options<CollectionGroupsV1PatchData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).patch<CollectionGroupsV1PatchResponse, CollectionGroupsV1PatchError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/groups/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create new Category
 * Create Collection category. Categories with same name may exist.
 *
 * Successful response will return the created category.
 *
 */
export const collectionGroupsV1Post = <ThrowOnError extends boolean = false>(options?: Options<CollectionGroupsV1PostData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<CollectionGroupsV1PostResponse, CollectionGroupsV1PostError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/collection/groups/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Waitlist Stats
 * Get Waitlist statistics for a game
 *
 * > Note: stats do not take into consideration users' regions.
 * > If they have set their price limit to be a historical low, stats will be computed
 * > for all users as if they were in the region you specify
 *
 */
export const statsWaitlistV1 = <ThrowOnError extends boolean = false>(options: Options<StatsWaitlistV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StatsWaitlistV1Response, StatsWaitlistV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/stats/waitlist/v1',
        ...options
    });
};

/**
 * Most Waitlisted
 * Get list of most Waitlisted games
 *
 */
export const statsMostWaitlistedV1 = <ThrowOnError extends boolean = false>(options?: Options<StatsMostWaitlistedV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StatsMostWaitlistedV1Response, StatsMostWaitlistedV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/stats/most-waitlisted/v1',
        ...options
    });
};

/**
 * Most Collected
 * Get list of most Collected games
 *
 */
export const statsMostCollectedV1 = <ThrowOnError extends boolean = false>(options?: Options<StatsMostCollectedV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StatsMostCollectedV1Response, StatsMostCollectedV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/stats/most-collected/v1',
        ...options
    });
};

/**
 * Most Popular
 * Get list of most popular games. Popularity for each game is computed as Waitlisted count + Collected count.
 *
 */
export const statsMostPopularV1 = <ThrowOnError extends boolean = false>(options?: Options<StatsMostPopularV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<StatsMostPopularV1Response, StatsMostPopularV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/stats/most-popular/v1',
        ...options
    });
};

/**
 * User Info
 * Get user info, currently just a username
 */
export const userInfoV2 = <ThrowOnError extends boolean = false>(options?: Options<UserInfoV2Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UserInfoV2Response, UserInfoV2Error, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/user/info/v2',
        ...options
    });
};

/**
 * Delete notes
 * Delete game notes. This operation is atomic.
 *
 */
export const userNotesV1Delete = <ThrowOnError extends boolean = false>(options: Options<UserNotesV1DeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, UserNotesV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/user/notes/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get notes
 * Get user's game notes
 *
 */
export const userNotesV1Get = <ThrowOnError extends boolean = false>(options?: Options<UserNotesV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<UserNotesV1GetResponse, UserNotesV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/user/notes/v1',
        ...options
    });
};

/**
 * Add or edit notes
 * Add or edit game notes. This operation is atomic and idempotent.
 *
 */
export const userNotesV1Put = <ThrowOnError extends boolean = false>(options: Options<UserNotesV1PutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<unknown, UserNotesV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/user/notes/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Unlink profile
 */
export const profilesLinkV1Delete = <ThrowOnError extends boolean = false>(options: Options<ProfilesLinkV1DeleteData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<unknown, ProfilesLinkV1DeleteError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/profiles/link/v1',
        ...options
    });
};

/**
 * Link profile
 * Profile is an object identifying remote account. You need linked profile to use sync endpoints.
 *
 * After successful link you will get profile token, which is used in subsequent profile operations,
 * usually as an `ITAD-Profile` header.
 *
 * Linking is idempotent, if you lose your token, or you need it in different instance of your app,
 * you can link the same profile again.
 *
 */
export const profilesLinkV1Put = <ThrowOnError extends boolean = false>(options: Options<ProfilesLinkV1PutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<ProfilesLinkV1PutResponse, ProfilesLinkV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/profiles/link/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Sync Waitlist
 * Sync Waitlist with IsThereAnyDeal. User can set category for your profile and default notification rules
 * in their [settings](https://isthereanydeal.com/settings/profiles/), same as with natively supported profiles.
 *
 */
export const profilesSyncWaitlistV1Put = <ThrowOnError extends boolean = false>(options: Options<ProfilesSyncWaitlistV1PutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<ProfilesSyncWaitlistV1PutResponse, ProfilesSyncWaitlistV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/profiles/sync/waitlist/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Sync Collection
 * Sync Collection with IsThereAnyDeal. User can set category for your profile
 * in their [settings](https://isthereanydeal.com/settings/profiles/), same as with natively supported profiles.
 *
 * Games are synced as redeemed copies. If there already is a redemeed copy with the same shop in user's Collection,
 * new copy will not be added.
 *
 */
export const profilesSyncCollectionV1Put = <ThrowOnError extends boolean = false>(options: Options<ProfilesSyncCollectionV1PutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<ProfilesSyncCollectionV1PutResponse, ProfilesSyncCollectionV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/profiles/sync/collection/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List notifications
 * Get user's notifications
 */
export const notificationsListV1Get = <ThrowOnError extends boolean = false>(options?: Options<NotificationsListV1GetData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<NotificationsListV1GetResponse, NotificationsListV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/notifications/v1',
        ...options
    });
};

/**
 * Waitlist notification detail
 * Get details of Waitlist notification
 */
export const notificationsWaitlistV1Get = <ThrowOnError extends boolean = false>(options: Options<NotificationsWaitlistV1GetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<NotificationsWaitlistV1GetResponse, NotificationsWaitlistV1GetError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/notifications/waitlist/v1',
        ...options
    });
};

/**
 * Mark notification read
 * Mark single notification as read
 */
export const notificationsReadV1Put = <ThrowOnError extends boolean = false>(options: Options<NotificationsReadV1PutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<NotificationsReadV1PutResponse, NotificationsReadV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/notifications/read/v1',
        ...options
    });
};

/**
 * Mark all notifications read
 * Mark all notifications as read
 */
export const notificationsReadAllV1Put = <ThrowOnError extends boolean = false>(options?: Options<NotificationsReadAllV1PutData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).put<NotificationsReadAllV1PutResponse, NotificationsReadAllV1PutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/notifications/read/all/v1',
        ...options
    });
};

/**
 * Get Shops
 * Return information about shops
 */
export const serviceShopsV1 = <ThrowOnError extends boolean = false>(options?: Options<ServiceShopsV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ServiceShopsV1Response, ServiceShopsV1Error, ThrowOnError>({
        url: '/service/shops/v1',
        ...options
    });
};

/**
 * Early Access Games
 * Returns list of Steam appids, which are currently considered to be early in early access
 */
export const internalEarlyaccessV1 = <ThrowOnError extends boolean = false>(options?: Options<InternalEarlyaccessV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<InternalEarlyaccessV1Response, InternalEarlyaccessV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/early-access/v1',
        ...options
    });
};

/**
 * Number of Players Statistics
 */
export const internalPlayersV1 = <ThrowOnError extends boolean = false>(options: Options<InternalPlayersV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<InternalPlayersV1Response, InternalPlayersV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/players/v1',
        ...options
    });
};

/**
 * HowLongToBeat Overview
 */
export const internalHltbV1 = <ThrowOnError extends boolean = false>(options: Options<InternalHltbV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<InternalHltbV1Response, InternalHltbV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/hltb/v1',
        ...options
    });
};

/**
 * Reviews Score
 * Returns Metacritic user reviews overview and OpenCritic overview for a given game
 */
export const internalReviewsV1 = <ThrowOnError extends boolean = false>(options: Options<InternalReviewsV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<InternalReviewsV1Response, InternalReviewsV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/reviews/v1',
        ...options
    });
};

/**
 * Conversion Rates
 */
export const internalRatesV1 = <ThrowOnError extends boolean = false>(options?: Options<InternalRatesV1Data, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<InternalRatesV1Response, InternalRatesV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/rates/v1',
        ...options
    });
};

/**
 * Excluded from Family Sharing
 */
export const internalExfglsV1 = <ThrowOnError extends boolean = false>(options: Options<InternalExfglsV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<InternalExfglsV1Response, InternalExfglsV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/exfgls/v1',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Current stream of Twitch channel
 */
export const internalTwitchstreamV1 = <ThrowOnError extends boolean = false>(options: Options<InternalTwitchstreamV1Data, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<InternalTwitchstreamV1Response, InternalTwitchstreamV1Error, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'key',
                type: 'apiKey'
            }
        ],
        url: '/internal/twitch/stream/v1',
        ...options
    });
};